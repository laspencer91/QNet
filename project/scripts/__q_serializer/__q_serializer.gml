/*******************************************************************************************************************
*   ______          _______. _______ .______       __       ___       __       __   ________   _______ .______      
*  /  __  \        /       ||   ____||   _  \     |  |     /   \     |  |     |  | |       /  |   ____||   _  \     
* |  |  |  |      |   (----`|  |__   |  |_)  |    |  |    /  ^  \    |  |     |  | `---/  /   |  |__   |  |_)  |    
* |  |  |  |       \   \    |   __|  |      /     |  |   /  /_\  \   |  |     |  |    /  /    |   __|  |      /     
* |  `--'  '--..----)   |   |  |____ |  |\  \----.|  |  /  _____  \  |  `----.|  |   /  /----.|  |____ |  |\  \----.
*  \_____\_____\_______/    |_______|| _| `._____||__| /__/     \__\ |_______||__|  /________||_______|| _| `._____|
*
*********************************************************************************************************************/                                                                                                           

/// feather ignore all

#region --------------------------------- MACROS ---------------------------------

// Each serialized buffer includes an identifier as its first piece of data.
// Configuring this can open space for more identifiers. DEFAULT = buffer_u8 (255 MAXIMUM serializable_ids)
#macro SERIALIZABLE_ID_BUFFER_TYPE buffer_u8
// Custom Buffer Type Identifier
#macro CUSTOM_BUFFER_SERIALIZER 15
// Manual Serializer Macro
#macro MANUAL_SERIALIZATION static __use_manual_serialization = true

#endregion -----------------------------------------------------------------------

#region ----------------------------- LOGGING MESSAGES ---------------------------
#macro __QSERIALIZER_STRING_SERIALIZATION_EXAMPLE @"function ExampleStruct(_xx) constructor 
{ 
	MANUAL_SERIALIZATION
	
	xx = _xx; 
	
	OnReceive = function() 
	{
		show_debug_message(xx);
	}
	
	Write = function(_buffer) 
	{
		buffer_write(_buffer, buffer_u16, xx);
	}
	
	Read = function(_buffer) 
	{
		xx = buffer_write(_buffer, buffer_u16);
	}
}"
#endregion ----------------------------------------------------------------------

/// @param {Array} _structs Array of Struct Ids that the Serializer handles. All Struct types used during serialization should be included here.
/// @param {Struct,Undefined} _header_config Configuration for serializing additional header types. Only base gm buffer types are supported. EX: { reliable: buffer_u8, id: buffer_u16 }
function QSerializerConfiguration(_structs, _header_config = {}) constructor
{
	header_config = _header_config;
	structs = _structs;
}

/// Contains serialization configuration for QSerializer, for a specific Struct.
/// @param {Id.Struct} _struct_id The GM Struct ID is used to create instances of the Struct during serialization.
/// @param {Array} _data_types The array of types that is iterated through, used to serialize and deserialize data.
/// @param {Bool} _uses_manual_serialization If true, this struct should be set up with the correct Read and Write functions to manually serialize data.
function __QStructSerializationConfig(_struct_id, _data_types, _uses_manual_serialization) constructor 
{
	struct_id  = _struct_id;
	data_types = _data_types;
	uses_manual_serialization = _uses_manual_serialization;
}

/// Class containing methods for serialization and deserialization of Structs.
/// @param {Struct.QSerializerConfiguration} _configuration new QSerializerConfiguration([Struct1, Struct2, ...], { custom_header_prop: buffer_u8 });
function QSerializer(_configuration) constructor
{
	#region --------------------------------- Initialization ---------------------------------
	
	// Auto incremented counter for assigning packet ids.
	__next_serializable_id = 0;
	// Maps a GM Struct ID to a QSerializer ID assigned to that struct.
	__struct_id_to_serializable_id_map = ds_map_create();
	// Maps a QSerializer ID to its QStructSerializationConfig.
	__struct_serialization_config_map  = ds_map_create();
	
	if (!struct_exists(_configuration, "structs"))
	{
		q_error("Cannot initialize QSerializer without a structs array.",
				   "Include a structs property as an array when declaring your QSerializer instance.",
				   "new QSerializer({ structs: [ExampleStruct] })");
	}
	
	// Initialize the header config. This will be used to read / write header data into a buffer on each request.
	__header_serialization_config = variable_struct_get(_configuration, "header_config") != undefined 
								      ? _configuration.header_config 
								      : undefined;
	
	// A QSerializer header ALWAYS contains a Struct Identifier. This is not a GM Struct Identifier. It is an identifier
	// generated by QSerializer to minimize header byte size.
	__HEADER_SIZE = buffer_sizeof(SERIALIZABLE_ID_BUFFER_TYPE);
	
	// Calculate header size, and pre-cache header prop names for serialization.
	if (!is_undefined(__header_serialization_config))
	{
		__header_prop_names = variable_struct_get_names(__header_serialization_config);
		struct_foreach(__header_serialization_config, function(_field_name, _buffer_type) {
			__HEADER_SIZE += buffer_sizeof(_buffer_type);
		});
	}
	
	// Register the list of structs sent into the constructors configuratiion
	for (var _i = 0; _i < array_length(_configuration.structs); _i++)
	{
		__RegisterSerializable(_configuration.structs[_i]);
	}
	
	#endregion -----------------------------------------------------------------------

	#region ------------------------------ Serialize/Deserialize -----------------------------

	/// @desc Creates a buffer and writes it by serializing the struct
	/// @param {Struct} _struct_instance An instance of a struct that is recognized by QSerializer by registration.
	/// @param {Struct} _header_data A struct containing data to be encoded into the header of the serialized packet.
	/// @returns {Id.Buffer,undefined} Buffer with serialized data written. Or undefined(-10) if it could not be written.
	function Serialize(_struct_instance, _header_data = {}) 
	{	
		if (!is_struct(_struct_instance))
		{
			q_error($"Error attempting to execute Serialize({_struct_instance}). \nNo struct instance was provided to be serialized.", 
					   ["Did you forget the keyword 'new'?", "Make sure you are attempting to send an instance of a struct."], 
					   "Serialize(new SomeStruct(10, 30.2))");
		}
	
		var _struct_id = asset_get_index(instanceof(_struct_instance));
		var _serializable_id = __struct_id_to_serializable_id_map[? _struct_id];

		if (_serializable_id == undefined)
		{
			q_error($"NO ID FOUND FOR STRUCT: {instanceof(_struct_instance)}", 
						"Is it registered with QSerializer via new QSerializer([])?",
			            "new QSerializer([Struct1, Struct2, YourStructName])");
		}

		// Array of data types that were registered with packet_layout_register
		var _serialization_config = __struct_serialization_config_map[? _serializable_id];
		var _data_types = _serialization_config.data_types;

		if (_serialization_config == undefined)
		{
			q_error($"There is no registered serialization config for packet type: {_serializable_id}",
			            "This is a bug and should be reported. \nEmail: laspencer@live.com \nI will response as quickly as possible.",
						"__struct_serialization_config_map[? _serializable_id] should contain the configuration for your serializable struct.");
		}

		// Create buffer and write packet identifier
		var _buffer = buffer_create(1, buffer_grow, 1);
		buffer_write(_buffer, SERIALIZABLE_ID_BUFFER_TYPE, _serializable_id);
		
		// WRITE HEADER AS CONFIGURED IN CONSTRUCTION OF THE SERIALIZER
		if (!is_undefined(__header_serialization_config))
		{
			for (var _i = 0; _i < array_length(__header_prop_names); _i++)
			{
				var _header_field_name = __header_prop_names[_i];
				var _header_field_data_type = __header_serialization_config[$ _header_field_name];
				buffer_write(_buffer, _header_field_data_type, _header_data[$ _header_field_name]);
			}
		}
		q_log($"[WRITING] BUFFER TELL AFTER HEADER {buffer_tell(_buffer)}", QLOG_LEVEL.DEEP_DEBUG);

		// WRITE DATA FROM STRUCT
		if (_serialization_config.uses_manual_serialization)
		{
			// USES MANUAL SERIALIZATION
			try 
			{
				_struct_instance.Write(_buffer);
			} 
			catch(_exception) 
			{
				if (string_pos("<unknown_object>.Write", _exception.message))
				{
					q_error($"[UNIMPLEMENTED] {instanceof(_struct_instance)}.Write() may be unimplemented.",
					            ["You have marked a registered a struct with MANUAL_SERIALIZATION.", "This struct requires a Write() function to be implemented."],
								__QSERIALIZER_STRING_SERIALIZATION_EXAMPLE);
				}
				else
				{
					show_error(_exception.longMessage, false);	
				}
			}
		}
		else
		{
			// USES BUILD IN SERIALIZATION
			__StructToBuffer(_buffer, _struct_id, _struct_instance);	// Recursive
		}

		buffer_resize(_buffer, buffer_tell(_buffer));

		return _buffer;
	}
	
	/// Deserializes data in a buffer to a registered struct instance.
	/// @param {Id.Buffer} _buffer A buffer with data to be deserialized. For example, a received network packet./
	/// @returns {Struct, undefined}
	function Deserialize(_buffer)
	{
		buffer_seek(_buffer, buffer_seek_start, 0);

		// Read serializable_id (packet identifier). This will allow us to lookup the type of data to expect.	
		var _serializable_id = buffer_read(_buffer, SERIALIZABLE_ID_BUFFER_TYPE);
		var _header_data = {}
		
		q_log($"[READING] BUFFER TELL BEFORE HEADER {buffer_tell(_buffer)}", QLOG_LEVEL.DEEP_DEBUG);
		if (!is_undefined(__header_serialization_config))
		{
			for (var _i = 0; _i < array_length(__header_prop_names); _i++)
			{
				var _header_field_name = __header_prop_names[_i];
				var _header_field_data_type = __header_serialization_config[$ _header_field_name];
				_header_data[$ _header_field_name] = buffer_read(_buffer, _header_field_data_type);
			}
		}
		q_log($"[READING] BUFFER TELL AFTER HEADER {buffer_tell(_buffer)}", QLOG_LEVEL.DEEP_DEBUG);
		
		// Retrieve configuration for the identified struct.
		var _serialization_config = __struct_serialization_config_map[? _serializable_id];
		if (_serialization_config == undefined)
		{
			q_error_quiet($"Attempted to process an unrecognized serializable_id ({_serializable_id}). If you are receiving data from external sources (networking), they could have passed incorrect data.");
			return undefined;
		}

		if (_serialization_config.uses_manual_serialization)
		{
			var _struct_instance = new _serialization_config.struct_id();
		
			try 
			{
				_struct_instance.Read(_buffer);
			} 
			catch(_exception) 
			{
				if (string_pos("<unknown_object>.Read", _exception.message))
				{
					q_error($"[UNIMPLEMENTED] {instanceof(_struct_instance)}.Read() may be unimplemented.",
								["You have marked a registered a struct with MANUAL_SERIALIZATION.", "This struct requires a Read() function to be implemented."],
								__QSERIALIZER_STRING_SERIALIZATION_EXAMPLE);
				}
				else
				{
					show_error(_exception.longMessage, false);	
				}
			}
		
			return { struct: _struct_instance, header_data: _header_data };
		}
		else
		{	
			// Standard deserizalation
			var _struct_id = _serialization_config.struct_id;
	
			// Get to the right place after serializable_id (which is the first byte)
			buffer_seek(_buffer, buffer_seek_start, __HEADER_SIZE); // << Calculate header size

			return { struct: __BufferToStruct(_buffer, _struct_id), header_data: _header_data };
		}	
	}

	#endregion --------------------------------------------------------------------------------

	#region -------------------------------- Private Utilities -------------------------------

	/// Writes a struct to a buffer. The struct must be recognized by QSerializer.
	/// Recursive  function, will end on a data type not being an array.
	function __StructToBuffer(_buffer, _struct_id, _struct_instance)
	{
		var _serializable_id = __struct_id_to_serializable_id_map[? _struct_id];
		var _serialization_config = __struct_serialization_config_map[? _serializable_id];
	
		if (_serialization_config == undefined)
		{
			q_error($"While attempting to write struct to a buffer, there is no registered serialization config for struct: {instanceof(_struct_instance)}.",
			            "This struct should be included with new QSerializer(_configuration) configuration.",
						"new QSerializer([ExampleStruct]);");
		}
	
		var _serialization_config_data_types = _serialization_config.data_types;
	
		var _struct_field_names_array = struct_get_variable_names(_struct_instance);

		for (var _a = 0; _a < array_length(_struct_field_names_array); _a++) 
		{
			var _field_name	  = _struct_field_names_array[_a];
			var _data_type	  = _serialization_config_data_types[_a];
			var _field_value  = _struct_instance[$ _field_name];
			
			q_log($"Writing data type {_data_type} to buffer.", QLOG_LEVEL.DEEP_DEBUG);
		
			if (_data_type == buffer_string && !is_string(_field_value))
				q_log("When building a registered message, a string was expected but a 'real' number was passed.");	
			if (is_string(_field_value) && _data_type != buffer_string)
				q_log("When building a registered message, a string was passed in but a 'real' number was expected.");
		
			if (is_array(_data_type))
			{
				// Handles an array type
				var _array_data_type = _data_type[0];
			
				if (_array_data_type == CUSTOM_BUFFER_SERIALIZER)
				{
					// Data type will be handled by a custom serializer.
					var _serializer = _data_type[1];
					if (_serializer == undefined) 
					{ 
						q_error("[PACKET WRITE] Custom buffer reader not setup correctly.",
						           "Reader needs to be specified.", 
								   "function ExampleStruct(datafield = [ CUSTOM_BUFFER_SERIALIZER, reader_function_name ]) constructor {"); 
					}
					_serializer.write(_buffer, _field_value);	// Pass the buffer and the data off to the custom serializer
				}
				else
				{
					// Data type is an Array of a Type
					// We begin by writing the length of the array.
					var _array_length = array_length(_field_value);
					buffer_write(_buffer, buffer_u16, _array_length);
				
					if (__IsStruct(_array_data_type))
					{
						// The data type is an array of a Structs. Call this function recursively.
						for (var _ei = 0; _ei < _array_length; _ei++) 
						{
							__StructToBuffer(_buffer, _array_data_type, _field_value[_ei]);
						}
					}
					else 
					{
						// The data type is an array of "primitives" (buffer_u8, buffer_u16, etc...)
						// Write the data into the buffer.
						for (var _ei = 0; _ei < _array_length; _ei++) 
						{
							buffer_write(_buffer, _array_data_type, _field_value[_ei]);
						}
					}
				}
			}
			else if (__IsStruct(_data_type)) 
			{
				// Handles writing of a single struct
				__StructToBuffer(_buffer, _data_type, _field_value);
			}
			else
			{
				// Handles the writing of a single primitive (buffer_u8, buffer_u16, etc...) type.
				buffer_write(_buffer, _data_type, _field_value);
			}
		}	
	}

	/// Produces a Struct from the data in a buffer.
	/// @param {Id.Buffer} _buffer
	/// @param {Id.Struct} _struct_type
	function __BufferToStruct(_buffer, _struct_type) 
	{
		var _serializable_id = __struct_id_to_serializable_id_map[? _struct_type];
		var _serialization_config = __struct_serialization_config_map[? _serializable_id];
	
		if (_serialization_config == undefined)
		{
			q_error($"While attempting to read buffer to a struct, there is no registered serialization config for struct: {instanceof(_struct_type)}.",
			            "This struct should be included with QSerializer([]).",
						"new QSerializer([ExampleStruct]);");
		}
	
		var _serialization_config_data_types = _serialization_config.data_types;
	
		// Read the buffer, one data type at a time, storing the read data into this array.
		var _data = array_create(array_length(_serialization_config_data_types));
		for (var _i = 0; _i < array_length(_serialization_config_data_types); _i++)
		{
			var _curr_field_datatype = _serialization_config_data_types[_i];
		
			q_log($"Reading data type {_curr_field_datatype} from buffer.", QLOG_LEVEL.DEEP_DEBUG);
		
			if (is_array(_curr_field_datatype))
			{
				var _array_type = _curr_field_datatype[0];
				if (_array_type == CUSTOM_BUFFER_SERIALIZER)
				{
					var _buffer_reader = _curr_field_datatype[1];
					if (_buffer_reader == undefined) 
					{ 
						q_error("[PACKET READ] Custom buffer reader not setup correctly.", 
						           "Reader needs to be specified.",
								   "function ExampleStruct(_field = [ CUSTOM_BUFFER_SERIALIZER, reader_function_name ]) constructor {");
					}
				
					_data[_i] = _buffer_reader.read(_buffer);
				}
				else 
				{
					var _num_of_array_entries = buffer_read(_buffer, buffer_u16);
					var _sub_array		      = array_create(_num_of_array_entries, undefined);
			
					if (__IsStruct(_array_type))
					{
						// Read in an array of structs. Returns [FilledOutStructInstances]
						for (var _ae = 0; _ae < _num_of_array_entries; _ae++) 
						{
							_sub_array[_ae] = __BufferToStruct(_buffer, _array_type);
						}	
					}
					else
					{
						// Read in an array of Gamemaker types.
						for (var _ae = 0; _ae < _num_of_array_entries; _ae++) 
						{
							_sub_array[_ae] = buffer_read(_buffer, _array_type);
						}	
					}
			
					_data[_i] = _sub_array;
				}
			}
			else if (__IsStruct(_curr_field_datatype))
			{
				_data[_i] = __BufferToStruct(_buffer, _curr_field_datatype);
			}
			else
			{
				_data[_i] = buffer_read(_buffer, _curr_field_datatype); // Read single data normally
			}
		}
		// Construct the struct instance, piling all the previously read data into it.
		var _struct_inst = new _struct_type(); // Data type is a struct, we create an instance. And fill it out.
		var _field_names = struct_get_variable_names(_struct_inst);
			
		for (var _ei = 0; _ei < array_length(_data); _ei++) 
		{
			_struct_inst[$ _field_names[_ei]] = _data[_ei];
		}

		return _struct_inst;
	}

	/// Registers a serializable struct to this QSerializer. Assigns that struct an ID
	/// @param {Function} _struct_id A struct to register. This should not be a function call "Struct()" but rather the id "Struct"
	static __RegisterSerializable = function(_struct_id)
	{
		var _struct = new _struct_id();
		var _struct_property_names = struct_get_variable_names(_struct);
	
		// If there is data we need to build the array
		var _array_of_types = array_create(array_length(_struct_property_names));
		for (var _i = 0; _i < array_length(_struct_property_names); _i++)
		{
			var _data_type = _struct[$ _struct_property_names[_i]];
			if (_data_type == CUSTOM_BUFFER_SERIALIZER)
			{
				// TODO: Find out if this is useable? Or needed? Don't remember writing this.
				//       What does it do?
				_array_of_types[_i] = [CUSTOM_BUFFER_SERIALIZER, _struct]; // The struct itself is flagged as having custom serialize functions to be used for this data.
			}
			else
			{
				_array_of_types[_i] = _data_type;		// The data type is a regular GM buffer type
			}
		}
	
		var _uses_manual_serialization = _struct[$ "__use_manual_serialization"] == true;
		__struct_serialization_config_map[? __next_serializable_id] = new __QStructSerializationConfig(_struct_id, _array_of_types, _uses_manual_serialization);
		__struct_id_to_serializable_id_map[? _struct_id] = __next_serializable_id;

		show_debug_message($"[{_uses_manual_serialization ? "MANUAL" : "DEFAULT"} SERIALIZABLE STRUCT REGISTERED] {script_get_name(_struct_id)} with Serializable ID: {__next_serializable_id}");

		return __next_serializable_id++;	
	}

	/// Returns whether a given function id exists.
	/// @param {Asset.GMScript} _number
	static __IsStruct = function(_number) 
	{
		if (_number > 100000 && script_exists(_number))
		{
			return true;
		}
	
		return false;
	}
	
	#endregion -----------------------------------------------------------------------
}


#region ------------------------ Global Utility Functions ----------------------------
///@desc Ommits method names. Gets property field names only.
///@param {Struct} _struct
function struct_get_variable_names(_struct) 
{
	var _field_names = variable_struct_get_names(_struct);

	var _filtered_array = [];
	for (var _i = 0; _i < array_length(_field_names); _i++) 
	{
		var _type = typeof(variable_struct_get(_struct, _field_names[_i]));
		if (_type != "method") 
		{
			array_push(_filtered_array, _field_names[_i]);
		}
	}
	return _filtered_array;
}
#endregion -----------------------------------------------------------------------